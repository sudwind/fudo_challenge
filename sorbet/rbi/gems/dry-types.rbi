# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/dry-types/all/dry-types.rbi
#
# dry-types-1.8.2

module Dry
  def self.Types(*namespaces, default: nil, **aliases); end
end
module Dry::Types
  def self.Rule(options); end
  def self.[](name); end
  def self.const_missing(const); end
  def self.container; end
  def self.define_builder(method, &block); end
  def self.identifier(klass); end
  def self.included(*); end
  def self.loader; end
  def self.module(*args, &block); end
  def self.register(name, type = nil, &block); end
  def self.registered?(class_or_identifier); end
  def self.rule_compiler; end
  def self.type_map; end
  extend Anonymous_Dry_Core_Deprecations_Tagged_11
  extend Anonymous_Dry_Core_Deprecations_Tagged_13
  extend Anonymous_Dry_Core_Deprecations_Tagged_15
  extend Anonymous_Module_10
  extend Anonymous_Module_12
  extend Anonymous_Module_14
  extend Dry::Core::ClassAttributes
  extend Dry::Core::ClassAttributes
  extend Dry::Core::Deprecations::Interface
  extend Dry::Core::Deprecations::Interface
  extend Dry::Core::Deprecations::Interface
  extend Dry::Core::Extensions
  include Dry::Core::Constants
end
module Anonymous_Module_10
  def inherited(klass); end
  def namespace(value = nil); end
end
class Dry::Types::CoercionError < StandardError
  def initialize(message, meta: nil, backtrace: nil); end
  def meta; end
  def self.handle(exception, meta: nil); end
end
class Dry::Types::MultipleError < Dry::Types::CoercionError
  def errors; end
  def initialize(errors); end
  def message; end
  def meta; end
end
class Dry::Types::SchemaError < Dry::Types::CoercionError
  def initialize(key, value, result); end
  def key; end
  def value; end
end
class Dry::Types::MapError < Dry::Types::CoercionError
end
class Dry::Types::SchemaKeyError < Dry::Types::CoercionError
end
class Dry::Types::MissingKeyError < Dry::Types::SchemaKeyError
  def initialize(key); end
  def key; end
end
class Dry::Types::UnknownKeysError < Dry::Types::SchemaKeyError
  def initialize(keys); end
  def keys; end
end
class Dry::Types::ConstraintError < Dry::Types::CoercionError
  def initialize(result, input); end
  def input; end
  def message; end
  def result; end
  def to_s; end
end
module Dry::Types::BuilderMethods
  def Array(type); end
  def Constant(object); end
  def Constructor(klass, cons = nil, &block); end
  def Hash(type_map); end
  def Instance(klass); end
  def Interface(*methods); end
  def Map(key_type, value_type); end
  def Nominal(klass); end
  def Strict(klass); end
  def Value(value); end
  def included(base); end
end
class Dry::Types::Module < Module
  def check_parameters(*namespaces, default: nil, **aliases); end
  def define_constants(constants, mod = nil); end
  def initialize(registry, *args, **kwargs); end
  def registry_tree; end
  def type_constants(*namespaces, default: nil, **aliases); end
end
module Dry::Types::Type
  def ===(input = nil); end
  def [](input = nil, &); end
  def call(input = nil, &); end
  def safe(*args, &block); end
  def valid?(input = nil); end
  extend Anonymous_Dry_Core_Deprecations_Tagged_16
  extend Dry::Core::Deprecations::Interface
end
module Anonymous_Dry_Core_Deprecations_Tagged_16
end
module Dry::Types::Options
  def initialize(*args, **options); end
  def options; end
  def with(**new_options); end
end
module Dry::Types::Meta
  def initialize(*args, meta: nil, **options); end
  def meta(data = nil); end
  def pristine; end
  def with(**options); end
end
module Dry::Types::Builder
  def &(other); end
  def <<(constructor = nil, **options, &block); end
  def >(other); end
  def >>(constructor = nil, **options, &block); end
  def append(constructor = nil, **options, &block); end
  def compose(other, composition_class); end
  def constrained(*, **, &); end
  def constrained_type; end
  def constructor(constructor = nil, **options, &block); end
  def constructor_type; end
  def default(input = nil, options = nil, &block); end
  def enum(*values); end
  def fallback(value = nil, shared: nil, &_fallback); end
  def lax; end
  def optional; end
  def prepend(constructor = nil, **options, &block); end
  def |(other); end
  include Dry::Core::Constants
end
module Dry::Types::Printable
  def inspect; end
  def to_s; end
end
class Dry::Types::Nominal
  def call_safe(input, &); end
  def call_unsafe(input); end
  def coerce(input, &); end
  def constrained?; end
  def default?; end
  def failure(input, error); end
  def initialize(primitive, **options); end
  def lax; end
  def name; end
  def optional?; end
  def primitive; end
  def primitive?(value); end
  def self.[](primitive); end
  def success(input); end
  def to_ast(meta: nil); end
  def to_proc; end
  def try(input, &); end
  def try_coerce(input); end
  include Anonymous_Dry_Core_Equalizer_17
  include Dry::Core::Equalizer::Methods
  include Dry::Types::Builder
  include Dry::Types::Meta
  include Dry::Types::Options
  include Dry::Types::Printable
  include Dry::Types::Type
end
module Anonymous_Dry_Core_Equalizer_17
  def cmp?(comparator, other); end
  def freeze; end
  def hash; end
end
module Anonymous_Dry_Core_Deprecations_Tagged_11
end
module Anonymous_Module_12
  def const_missing(missing); end
end
class Dry::Types::Container
  def config; end
  extend Anonymous_Dry_Configurable_Extension_18
  extend Dry::Configurable
  extend Dry::Configurable::ClassMethods
  extend Dry::Core::Container::Configuration
  include Dry::Core::Container::Mixin
end
module Anonymous_Dry_Configurable_Extension_18
end
class Dry::Types::Array < Dry::Types::Nominal
  def constructor_type; end
  def of(type); end
end
class Dry::Types::Hash < Dry::Types::Nominal
  def build_keys(type_map); end
  def constructor_type; end
  def key_name(key); end
  def map(key_type, value_type); end
  def permissive(*); end
  def resolve_type(type); end
  def schema(keys_or_map, meta = nil); end
  def strict(*); end
  def strict_with_defaults(*); end
  def symbolized(*); end
  def to_ast(meta: nil); end
  def transform_types?; end
  def weak(*); end
  def with_type_transform(proc = nil, &block); end
end
module Dry::Types::Decorator
  def __new__(type); end
  def constrained?; end
  def decorate?(response); end
  def default?; end
  def initialize(type, *, **); end
  def method_missing(meth, *, **, &); end
  def respond_to_missing?(meth, include_private = nil); end
  def to_proc; end
  def try(input, &); end
  def type; end
  include Dry::Types::Options
end
class Dry::Types::Constrained
  def ===(value); end
  def call_safe(input, &); end
  def call_unsafe(input); end
  def constrained(*nullary_rules, **unary_rules); end
  def constrained?; end
  def constructor_type; end
  def decorate?(response); end
  def initialize(type, **options); end
  def lax; end
  def parse_arguments(positional_arguments); end
  def rule; end
  def to_ast(meta: nil); end
  def try(input, &); end
  include Anonymous_Dry_Core_Equalizer_19
  include Dry::Core::Equalizer::Methods
  include Dry::Types::Builder
  include Dry::Types::Decorator
  include Dry::Types::Printable
  include Dry::Types::Type
end
module Anonymous_Dry_Core_Equalizer_19
  def cmp?(comparator, other); end
  def freeze; end
  def hash; end
end
class Dry::Types::Constructor < Dry::Types::Nominal
  def <<(new_fn = nil, **options, &block); end
  def >>(new_fn = nil, **options, &block); end
  def append(new_fn = nil, **options, &block); end
  def call_safe(input); end
  def call_unsafe(input); end
  def constrained_type; end
  def constructor(new_fn = nil, **options, &block); end
  def fn; end
  def initialize(type, fn: nil, **options); end
  def lax; end
  def method_missing(method, *, **, &); end
  def prepend(new_fn = nil, **options, &block); end
  def respond_to_missing?(meth, include_private = nil); end
  def self.[](type, fn:, **options); end
  def self.new(input, fn: nil, **options, &block); end
  def self.wrapper_type; end
  def to_ast(meta: nil); end
  def to_proc; end
  def try(input, &); end
  def type; end
  include Anonymous_Dry_Core_Equalizer_20
  include Dry::Core::Equalizer::Methods
end
module Anonymous_Dry_Core_Equalizer_20
  def cmp?(comparator, other); end
  def freeze; end
  def hash; end
end
class Dry::Types::Constructor::Function
  def <<(other); end
  def >>(other); end
  def [](input, &); end
  def arity; end
  def call(input, &); end
  def fn; end
  def initialize(fn); end
  def self.[](fn); end
  def self.yields_block?(fn); end
  def to_ast; end
  def wrapper?; end
  include Anonymous_Dry_Core_Equalizer_21
  include Dry::Core::Equalizer::Methods
end
class Dry::Types::Constructor::Function::Safe < Dry::Types::Constructor::Function
  def call(input, &); end
end
class Dry::Types::Constructor::Function::MethodCall < Dry::Types::Constructor::Function
  def initialize(fn); end
  def name; end
  def self.[](fn, safe); end
  def self.call_class(method, public, safe); end
  def target; end
  def to_ast; end
end
class Dry::Types::Constructor::Function::MethodCall::PublicCall < Dry::Types::Constructor::Function::MethodCall
  def self.call_interface(method, safe); end
end
class Dry::Types::Constructor::Function::MethodCall::PrivateCall < Dry::Types::Constructor::Function::MethodCall
  def call(input, &); end
end
class Dry::Types::Constructor::Function::MethodCall::PrivateSafeCall < Dry::Types::Constructor::Function::MethodCall::PrivateCall
  def call(input, &); end
end
class Dry::Types::Constructor::Function::Wrapper < Dry::Types::Constructor::Function
  def [](input, type, &); end
  def arity; end
  def call(input, type, &); end
end
module Anonymous_Dry_Core_Equalizer_21
  def cmp?(comparator, other); end
  def freeze; end
  def hash; end
  def inspect; end
end
class Dry::Types::Array::Constructor < Dry::Types::Constructor
  def constructor_type; end
  def lax; end
  def of(member); end
end
class Dry::Types::Hash::Constructor < Dry::Types::Constructor
  def constructor_type; end
  def lax; end
  def schema(*, **, &); end
end
module Dry::Types::Composition
  def call_safe(input, &); end
  def call_unsafe(input); end
  def constrained?; end
  def default?; end
  def failure(input, _error = nil); end
  def initialize(left, right, **options); end
  def left; end
  def name; end
  def optional?; end
  def primitive?(value); end
  def right; end
  def self.included(base); end
  def success(input); end
  def to_ast(meta: nil); end
  def to_proc; end
  def try(input, &); end
  include Anonymous_Dry_Core_Equalizer_22
  include Dry::Core::Equalizer::Methods
  include Dry::Types::Builder
  include Dry::Types::Meta
  include Dry::Types::Options
  include Dry::Types::Printable
  include Dry::Types::Type
end
module Anonymous_Dry_Core_Equalizer_22
  def cmp?(comparator, other); end
  def freeze; end
  def hash; end
end
module Dry::Types::Composition::Constrained
  def constrained?; end
  def rule; end
end
class Dry::Types::Sum
  def call_safe(input, &block); end
  def call_unsafe(input); end
  def constrained(*, **, &); end
  def meta(data = nil); end
  def optional?; end
  def primitive?(value); end
  def self.ast_type; end
  def self.composition_name; end
  def self.operator; end
  def try(input); end
  include Dry::Types::Composition
end
class Dry::Types::Sum::Constrained < Dry::Types::Sum
  include Dry::Types::Composition::Constrained
end
class Dry::Types::AnyClass < Dry::Types::Nominal
  def initialize(**options); end
  def name; end
  def self.name; end
  def to_ast(meta: nil); end
  def with(**new_options); end
end
module Dry::Types::Coercions
  def empty_str?(value); end
  def to_date(input, &); end
  def to_date_time(input, &); end
  def to_symbol(input, &); end
  def to_time(input, &); end
  include Dry::Core::Constants
end
module Dry::Types::Coercions::Params
  def self.to_ary(input, &); end
  def self.to_decimal(input, &); end
  def self.to_false(input, &); end
  def self.to_float(input, &); end
  def self.to_hash(input, &); end
  def self.to_int(input, &); end
  def self.to_nil(input, &); end
  def self.to_true(input, &); end
  extend Dry::Types::Coercions
end
module Dry::Types::Coercions::JSON
  def self.to_decimal(input, &); end
  def self.to_nil(input, &); end
  extend Dry::Types::Coercions
end
module Anonymous_Dry_Logic_Rule_Interface_23
  def [](input0, input1); end
  def call(input0, input1); end
end
class Dry::Logic::Rule::Predicate::Predicate2Arity < Dry::Logic::Rule::Predicate
  include Anonymous_Dry_Logic_Rule_Interface_23
end
module Anonymous_Dry_Logic_Rule_Interface_24
  def [](input0); end
  def call(input0); end
  def initialize(*); end
end
class Dry::Logic::Rule::Predicate::Predicate2Arity1Curried < Dry::Logic::Rule::Predicate
  include Anonymous_Dry_Logic_Rule_Interface_24
end
class Dry::Types::Printer
  def call(type); end
  def initialize; end
  def visit(type, &); end
  def visit_any(_); end
  def visit_array(type); end
  def visit_array_member(array); end
  def visit_callable(callable); end
  def visit_composition(composition, &); end
  def visit_constrained(constrained); end
  def visit_constructor(constructor); end
  def visit_default(default); end
  def visit_enum(enum); end
  def visit_hash(hash); end
  def visit_key(key); end
  def visit_lax(lax); end
  def visit_map(map); end
  def visit_nominal(type); end
  def visit_options(options, meta = nil); end
  def visit_schema(schema); end
end
class Dry::Types::Printer::Composition
  def initialize(printer, composition_class); end
  def visit(composition); end
  def visit_constructor(type, &); end
  def visit_constructors(composition); end
end
class Dry::Types::Constrained::Coercible < Dry::Types::Constrained
  def call_safe(input); end
  def call_unsafe(input); end
  def try(input, &); end
end
class Dry::Types::FnContainer
  def self.[](fn_name); end
  def self.container; end
  def self.register(function = nil, &block); end
  def self.register_name(function); end
end
class Dry::Types::Schema < Dry::Types::Hash
  def apply(hash, options = nil); end
  def call_safe(hash, options = nil); end
  def call_unsafe(hash, options = nil); end
  def clear; end
  def constrained?; end
  def each(&); end
  def initialize(_primitive, **options); end
  def key(name, fallback = nil, &); end
  def key?(name); end
  def keys; end
  def lax; end
  def merge(other); end
  def merge_keys(*keys); end
  def missing_key(key); end
  def name_key_map; end
  def resolve_missing_keys(hash, options); end
  def resolve_safe(hash, options = nil, &block); end
  def resolve_unsafe(hash, options = nil); end
  def schema(keys_or_map); end
  def strict(strict = nil); end
  def strict?; end
  def to_ast(meta: nil); end
  def transform_key; end
  def transform_keys?; end
  def try(input); end
  def unexpected_keys(hash_keys); end
  def with_key_transform(proc = nil, &block); end
  include Enumerable
end
class Dry::Types::Schema::Key
  def call_safe(input, &); end
  def call_unsafe(input); end
  def decorate?(response); end
  def initialize(type, name, required: nil, **options); end
  def lax; end
  def meta(data = nil); end
  def name; end
  def omittable; end
  def optional; end
  def required(required = nil); end
  def required?; end
  def to_ast(meta: nil); end
  def try(input, &); end
  extend Anonymous_Dry_Core_Deprecations_Tagged_25
  extend Dry::Core::Deprecations::Interface
  include Anonymous_Dry_Core_Equalizer_26
  include Dry::Core::Equalizer::Methods
  include Dry::Types::Builder
  include Dry::Types::Decorator
  include Dry::Types::Printable
  include Dry::Types::Type
end
module Anonymous_Dry_Core_Deprecations_Tagged_25
end
module Anonymous_Dry_Core_Equalizer_26
  def cmp?(comparator, other); end
  def freeze; end
  def hash; end
end
class Dry::Types::Map < Dry::Types::Nominal
  def assert_primitive(input); end
  def call_safe(hash); end
  def call_unsafe(hash); end
  def coerce(input); end
  def constrained?; end
  def initialize(primitive, key_type: nil, value_type: nil, meta: nil); end
  def key_type; end
  def name; end
  def to_ast(meta: nil); end
  def try(hash); end
  def value_type; end
end
class Dry::Types::Array::Member < Dry::Types::Array
  def call_safe(input); end
  def call_unsafe(input); end
  def constructor_type; end
  def initialize(primitive, **options); end
  def lax; end
  def member; end
  def to_ast(meta: nil); end
  def try(input, &block); end
end
class Dry::Types::Lax
  def [](input, &); end
  def call(input, &); end
  def call_safe(input, &); end
  def call_unsafe(input, &); end
  def decorate?(response); end
  def lax; end
  def to_ast(meta: nil); end
  def try(input, &); end
  include Anonymous_Dry_Core_Equalizer_27
  include Dry::Core::Equalizer::Methods
  include Dry::Types::Builder
  include Dry::Types::Decorator
  include Dry::Types::Printable
  include Dry::Types::Type
end
module Anonymous_Dry_Core_Equalizer_27
  def cmp?(comparator, other); end
  def freeze; end
  def hash; end
end
module Anonymous_Dry_Core_Deprecations_Tagged_13
end
module Anonymous_Module_14
  def const_missing(missing); end
end
class Dry::Types::Enum
  def call_safe(input, &); end
  def call_unsafe(input); end
  def default(*); end
  def each_value(&); end
  def include?(input = nil); end
  def initialize(type, **options); end
  def inspect; end
  def inverted_mapping; end
  def joined_values; end
  def map_value(input); end
  def mapping; end
  def name; end
  def to_ast(meta: nil); end
  def to_s; end
  def try(input, &); end
  def values; end
  include Anonymous_Dry_Core_Equalizer_28
  include Dry::Core::Equalizer::Methods
  include Dry::Types::Builder
  include Dry::Types::Decorator
  include Dry::Types::Type
end
module Anonymous_Dry_Core_Equalizer_28
  def cmp?(comparator, other); end
  def freeze; end
  def hash; end
end
class Dry::Types::Default
  def call_safe(input = nil, &); end
  def call_unsafe(input = nil); end
  def callable?; end
  def constrained(*, **, &); end
  def default?; end
  def evaluate; end
  def initialize(type, value, **); end
  def self.[](value); end
  def try(input = nil, &); end
  def valid?(value = nil); end
  def value; end
  include Anonymous_Dry_Core_Equalizer_29
  include Dry::Core::Equalizer::Methods
  include Dry::Types::Builder
  include Dry::Types::Decorator
  include Dry::Types::Printable
  include Dry::Types::Type
end
class Dry::Types::Default::Callable < Dry::Types::Default
  def callable?; end
  def evaluate; end
  include Anonymous_Dry_Core_Equalizer_30
  include Dry::Core::Equalizer::Methods
end
module Anonymous_Dry_Core_Equalizer_30
  def cmp?(comparator, other); end
  def freeze; end
  def hash; end
end
module Anonymous_Dry_Core_Equalizer_29
  def cmp?(comparator, other); end
  def freeze; end
  def hash; end
end
class Dry::Types::Intersection
  def call_safe(input, &); end
  def call_unsafe(input); end
  def merge_results(left_result, right_result); end
  def primitive?(value); end
  def self.ast_type; end
  def self.composition_name; end
  def self.operator; end
  def try(input); end
  def try_side(side, input); end
  def try_sides(input, &block); end
  include Dry::Types::Composition
end
class Dry::Types::Intersection::Constrained < Dry::Types::Intersection
  include Dry::Types::Composition::Constrained
end
class Dry::Types::Implication
  def call_safe(input, &); end
  def call_unsafe(input); end
  def primitive?(value); end
  def self.ast_type; end
  def self.composition_name; end
  def self.operator; end
  def try(input, &); end
  include Dry::Types::Composition
end
class Dry::Types::Implication::Constrained < Dry::Types::Implication
  include Dry::Types::Composition::Constrained
end
module Anonymous_Dry_Core_Deprecations_Tagged_15
end
