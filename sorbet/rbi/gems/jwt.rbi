# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/jwt/all/jwt.rbi
#
# jwt-2.10.1

module JWT
  def decode(jwt, key = nil, verify = nil, options = nil, &keyfinder); end
  def encode(payload, key, algorithm = nil, header_fields = nil); end
  def self.decode(jwt, key = nil, verify = nil, options = nil, &keyfinder); end
  def self.encode(payload, key, algorithm = nil, header_fields = nil); end
  def self.gem_version; end
  def self.openssl_3?; end
  def self.openssl_3_hmac_empty_key_regression?; end
  def self.openssl_version; end
  def self.rbnacl?; end
  def self.rbnacl_6_or_greater?; end
  extend JWT::Configuration
end
module JWT::VERSION
end
class JWT::Base64
  def self.loose_urlsafe_decode64(str); end
  def self.url_decode(str); end
  def self.url_encode(str); end
end
class JWT::JSON
  def self.generate(data); end
  def self.parse(data); end
end
class JWT::X5cKeyFinder
  def build_store(root_certificates, crls); end
  def from(x5c_header_or_certificates); end
  def initialize(root_certificates, crls = nil); end
  def parse_certificates(x5c_header_or_certificates); end
end
class JWT::Decode
  def alg_in_header; end
  def allowed_algorithms; end
  def allowed_and_valid_algorithms; end
  def decode_segments; end
  def find_key(&keyfinder); end
  def given_algorithms; end
  def initialize(jwt, key, verify, options, &keyfinder); end
  def none_algorithm?; end
  def resolve_allowed_algorithms; end
  def set_key; end
  def token; end
  def validate_segment_count!; end
  def verify_algo; end
  def verify_signature; end
end
module JWT::Configuration
  def configuration; end
  def configure; end
end
class JWT::Configuration::DecodeConfiguration
  def algorithms; end
  def algorithms=(arg0); end
  def initialize; end
  def leeway; end
  def leeway=(arg0); end
  def required_claims; end
  def required_claims=(arg0); end
  def to_h; end
  def verify_aud; end
  def verify_aud=(arg0); end
  def verify_expiration; end
  def verify_expiration=(arg0); end
  def verify_iat; end
  def verify_iat=(arg0); end
  def verify_iss; end
  def verify_iss=(arg0); end
  def verify_jti; end
  def verify_jti=(arg0); end
  def verify_not_before; end
  def verify_not_before=(arg0); end
  def verify_sub; end
  def verify_sub=(arg0); end
end
module JWT::JWK
  def self.classes; end
  def self.create_from(key, params = nil, options = nil); end
  def self.generate_mappings; end
  def self.import(key, params = nil, options = nil); end
  def self.mappings; end
  def self.new(key, params = nil, options = nil); end
end
class JWT::JWK::KidAsKeyDigest
  def generate; end
  def initialize(jwk); end
end
class JWT::JWK::Thumbprint
  def generate; end
  def initialize(jwk); end
  def jwk; end
  def to_s; end
end
class JWT::Configuration::JwkConfiguration
  def initialize; end
  def kid_generator; end
  def kid_generator=(arg0); end
  def kid_generator_type=(value); end
end
class JWT::Configuration::Container
  def decode; end
  def decode=(arg0); end
  def deprecation_warnings; end
  def deprecation_warnings=(value); end
  def initialize; end
  def jwk; end
  def jwk=(arg0); end
  def reset!; end
  def strict_base64_decoding; end
  def strict_base64_decoding=(arg0); end
end
module JWT::Deprecations
  def self.context; end
  def self.emit_warnings; end
  def self.record_warned(message); end
  def self.store(message); end
  def self.warning(message, only_if_valid: nil); end
end
module JWT::JWA
  def self.algorithms; end
  def self.create(algorithm); end
  def self.find(algo); end
  def self.register_algorithm(algo); end
  def self.resolve(algorithm); end
  def self.resolve_and_sort(algorithms:, preferred_algorithm:); end
end
module JWT::JWA::Compat
  def self.included(klass); end
end
module JWT::JWA::Compat::ClassMethods
  def from_algorithm(algorithm); end
  def sign(algorithm, msg, key); end
  def verify(algorithm, key, signing_input, signature); end
end
module JWT::JWA::SigningAlgorithm
  def alg; end
  def header(*); end
  def raise_sign_error!(message); end
  def raise_verify_error!(message); end
  def self.included(klass); end
  def sign(*); end
  def valid_alg?(alg_to_check); end
  def verify(*); end
end
module JWT::JWA::SigningAlgorithm::ClassMethods
  def register_algorithm(algo); end
end
class JWT::JWA::Ecdsa
  def asn1_to_raw(signature, public_key); end
  def curve_by_name(name); end
  def digest; end
  def initialize(alg, digest); end
  def raw_to_asn1(signature, private_key); end
  def self.curve_by_name(name); end
  def self.from_algorithm(algorithm); end
  def sign(data:, signing_key:); end
  def verify(data:, signature:, verification_key:); end
  extend JWT::JWA::Compat::ClassMethods
  extend JWT::JWA::SigningAlgorithm::ClassMethods
  include JWT::JWA::Compat
  include JWT::JWA::SigningAlgorithm
end
class JWT::JWA::Hmac
  def digest; end
  def initialize(alg, digest); end
  def self.from_algorithm(algorithm); end
  def sign(data:, signing_key:); end
  def verify(data:, signature:, verification_key:); end
  extend JWT::JWA::Compat::ClassMethods
  extend JWT::JWA::SigningAlgorithm::ClassMethods
  include JWT::JWA::Compat
  include JWT::JWA::SigningAlgorithm
end
module JWT::JWA::Hmac::SecurityUtils
  def fixed_length_secure_compare(a, b); end
  def secure_compare(a, b); end
  def self.fixed_length_secure_compare(a, b); end
  def self.secure_compare(a, b); end
end
class JWT::JWA::None
  def initialize; end
  def sign(*); end
  def verify(*); end
  extend JWT::JWA::Compat::ClassMethods
  extend JWT::JWA::SigningAlgorithm::ClassMethods
  include JWT::JWA::Compat
  include JWT::JWA::SigningAlgorithm
end
class JWT::JWA::Ps
  def digest_algorithm; end
  def initialize(alg); end
  def sign(data:, signing_key:); end
  def verify(data:, signature:, verification_key:); end
  extend JWT::JWA::Compat::ClassMethods
  extend JWT::JWA::SigningAlgorithm::ClassMethods
  include JWT::JWA::Compat
  include JWT::JWA::SigningAlgorithm
end
class JWT::JWA::Rsa
  def digest; end
  def initialize(alg); end
  def sign(data:, signing_key:); end
  def verify(data:, signature:, verification_key:); end
  extend JWT::JWA::Compat::ClassMethods
  extend JWT::JWA::SigningAlgorithm::ClassMethods
  include JWT::JWA::Compat
  include JWT::JWA::SigningAlgorithm
end
module JWT::JWA::Unsupported
  def self.sign(*); end
  def self.verify(*); end
end
class JWT::JWA::Wrapper
  def alg; end
  def header(*args, **kwargs); end
  def initialize(algorithm); end
  def sign(*args, **kwargs); end
  def valid_alg?(alg_to_check); end
  def verify(*args, **kwargs); end
  extend JWT::JWA::Compat::ClassMethods
  extend JWT::JWA::SigningAlgorithm::ClassMethods
  include JWT::JWA::Compat
  include JWT::JWA::SigningAlgorithm
end
class JWT::Encode
  def initialize(options); end
  def segments; end
end
class JWT::EncodeError < StandardError
end
class JWT::DecodeError < StandardError
end
class JWT::RequiredDependencyError < StandardError
end
class JWT::VerificationError < JWT::DecodeError
end
class JWT::ExpiredSignature < JWT::DecodeError
end
class JWT::IncorrectAlgorithm < JWT::DecodeError
end
class JWT::ImmatureSignature < JWT::DecodeError
end
class JWT::InvalidIssuerError < JWT::DecodeError
end
class JWT::UnsupportedEcdsaCurve < JWT::IncorrectAlgorithm
end
class JWT::InvalidIatError < JWT::DecodeError
end
class JWT::InvalidAudError < JWT::DecodeError
end
class JWT::InvalidSubError < JWT::DecodeError
end
class JWT::InvalidCritError < JWT::DecodeError
end
class JWT::InvalidJtiError < JWT::DecodeError
end
class JWT::InvalidPayload < JWT::DecodeError
end
class JWT::MissingRequiredClaim < JWT::DecodeError
end
class JWT::Base64DecodeError < JWT::DecodeError
end
class JWT::JWKError < JWT::DecodeError
end
class JWT::JWK::KeyFinder
  def initialize(options); end
  def key_for(kid); end
  def resolve_key(kid); end
end
class JWT::JWK::Set
  def +(enum); end
  def <<(key); end
  def ==(other); end
  def add(key); end
  def delete(*args, **, &block); end
  def dig(*args, **, &block); end
  def each(*args, **, &block); end
  def eql?(other); end
  def export(options = nil); end
  def filter!(&block); end
  def initialize(jwks = nil, options = nil); end
  def keys; end
  def length(*args, **, &block); end
  def merge(enum); end
  def reject!(&block); end
  def select!(&block); end
  def size(*args, **, &block); end
  def union(enum); end
  def uniq!(&block); end
  def |(enum); end
  extend Forwardable
  include Enumerable
end
class JWT::JWK::KeyBase
  def <=>(other); end
  def ==(other); end
  def [](key); end
  def []=(key, value); end
  def eql?(other); end
  def hash; end
  def initialize(options, params = nil); end
  def kid; end
  def parameters; end
  def self.inherited(klass); end
end
class JWT::JWK::EC < JWT::JWK::KeyBase
  def []=(key, value); end
  def check_jwk_params!(key_params, params); end
  def create_ec_key(jwk_crv, jwk_x, jwk_y, jwk_d); end
  def decode_octets(base64_encoded_coordinate); end
  def ec_key; end
  def encode_octets(octets); end
  def encode_open_ssl_bn(key_part); end
  def export(options = nil); end
  def extract_key_params(key); end
  def initialize(key, params = nil, options = nil); end
  def key_digest; end
  def keypair; end
  def keypair_components(ec_keypair); end
  def members; end
  def parse_ec_key(key); end
  def private?; end
  def public_key; end
  def self.import(jwk_data); end
  def self.to_openssl_curve(crv); end
  def signing_key; end
  def verify_key; end
end
class JWT::JWK::RSA < JWT::JWK::KeyBase
  def []=(key, value); end
  def check_jwk_params!(key_params, params); end
  def decode_open_ssl_bn(jwk_data); end
  def encode_open_ssl_bn(key_part); end
  def export(options = nil); end
  def extract_key_params(key); end
  def initialize(key, params = nil, options = nil); end
  def jwk_attributes(*attributes); end
  def key_digest; end
  def keypair; end
  def members; end
  def parse_rsa_key(key); end
  def private?; end
  def public_key; end
  def rsa_key; end
  def self.create_rsa_key(rsa_parameters); end
  def self.create_rsa_key_using_accessors(rsa_parameters); end
  def self.create_rsa_key_using_der(rsa_parameters); end
  def self.create_rsa_key_using_sets(rsa_parameters); end
  def self.decode_open_ssl_bn(jwk_data); end
  def self.import(jwk_data); end
  def self.validate_rsa_parameters!(rsa_parameters); end
  def signing_key; end
  def verify_key; end
end
class JWT::JWK::HMAC < JWT::JWK::KeyBase
  def []=(key, value); end
  def check_jwk(keypair, params); end
  def export(options = nil); end
  def extract_key_params(key); end
  def initialize(key, params = nil, options = nil); end
  def key_digest; end
  def keypair; end
  def members; end
  def private?; end
  def public_key; end
  def secret; end
  def self.import(jwk_data); end
  def signing_key; end
  def verify_key; end
end
module JWT::Claims
  def self.payload_errors(payload, *options); end
  def self.valid_payload?(payload, *options); end
  def self.verify!(payload, options); end
  def self.verify_payload!(payload, *options); end
end
class JWT::Claims::Audience
  def expected_audience; end
  def initialize(expected_audience:); end
  def verify!(context:, **_args); end
end
class JWT::Claims::Crit
  def expected_crits; end
  def initialize(expected_crits:); end
  def verify!(context:, **_args); end
end
class JWT::Claims::VerificationContext < Struct
  def payload; end
  def payload=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
module JWT::Claims::DecodeVerifier
  def self.verify!(payload, options); end
end
class JWT::Claims::Expiration
  def initialize(leeway:); end
  def leeway; end
  def verify!(context:, **_args); end
end
class JWT::Claims::IssuedAt
  def verify!(context:, **_args); end
end
class JWT::Claims::Issuer
  def initialize(issuers:); end
  def issuers; end
  def verify!(context:, **_args); end
end
class JWT::Claims::JwtId
  def initialize(validator:); end
  def validator; end
  def verify!(context:, **_args); end
end
class JWT::Claims::NotBefore
  def initialize(leeway:); end
  def leeway; end
  def verify!(context:, **_args); end
end
class JWT::Claims::Numeric
  def self.new(*args); end
  def self.verify!(payload:, **_args); end
  def validate_is_numeric(payload, claim); end
  def validate_numeric_claims(payload); end
  def verify!(context:); end
end
class JWT::Claims::Numeric::Compat
  def initialize(payload); end
  def verify!; end
end
class JWT::Claims::Required
  def initialize(required_claims:); end
  def required_claims; end
  def verify!(context:, **_args); end
end
class JWT::Claims::Subject
  def expected_subject; end
  def initialize(expected_subject:); end
  def verify!(context:, **_args); end
end
module JWT::Claims::VerificationMethods
  def claim_errors(*options); end
  def valid_claims?(*options); end
  def verify_claims!(*options); end
end
module JWT::Claims::Verifier
  def self.errors(context, *options); end
  def self.iterate_verifiers(*options); end
  def self.verify!(context, *options); end
  def self.verify_one!(context, verifier, options); end
end
class JWT::Claims::Error < Struct
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class JWT::EncodedToken
  def decode_payload; end
  def encoded_header; end
  def encoded_payload; end
  def encoded_payload=(arg0); end
  def encoded_signature; end
  def header; end
  def initialize(jwt); end
  def jwt; end
  def parse(segment); end
  def parse_and_decode(segment); end
  def parse_unencoded(segment); end
  def payload; end
  def signature; end
  def signing_input; end
  def to_s; end
  def unencoded_payload?; end
  def valid_signature?(algorithm:, key:); end
  def verify_signature!(algorithm:, key: nil, key_finder: nil); end
  include JWT::Claims::VerificationMethods
end
class JWT::Token
  def detach_payload!; end
  def encoded_header; end
  def encoded_payload; end
  def encoded_signature; end
  def header; end
  def initialize(payload:, header: nil); end
  def jwt; end
  def payload; end
  def sign!(algorithm:, key:); end
  def signature; end
  def signing_input; end
  def to_s; end
  include JWT::Claims::VerificationMethods
end
class JWT::ClaimsValidator
  def initialize(payload); end
  def validate!; end
end
class JWT::Verify
  def initialize(payload, options); end
  def self.verify_aud(payload, options); end
  def self.verify_claims(payload, options); end
  def self.verify_expiration(payload, options); end
  def self.verify_iat(payload, options); end
  def self.verify_iss(payload, options); end
  def self.verify_jti(payload, options); end
  def self.verify_not_before(payload, options); end
  def self.verify_required_claims(payload, options); end
  def self.verify_sub(payload, options); end
  def verify_aud; end
  def verify_expiration; end
  def verify_iat; end
  def verify_iss; end
  def verify_jti; end
  def verify_not_before; end
  def verify_required_claims; end
  def verify_sub; end
end
