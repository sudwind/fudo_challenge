# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/rack/all/rack.rbi
#
# rack-3.1.13

module Rack
  def self.release; end
end
module Rack::Auth
end
class Rack::BodyProxy
  def close; end
  def closed?; end
  def initialize(body, &block); end
  def method_missing(method_name, *args, **, &block); end
  def respond_to_missing?(method_name, include_all = nil); end
end
class Rack::Cascade
  def <<(app); end
  def add(app); end
  def apps; end
  def call(env); end
  def include?(app); end
  def initialize(apps, cascade_for = nil); end
end
class Rack::URLMap
  def call(env); end
  def casecmp?(v1, v2); end
  def initialize(map = nil); end
  def remap(map); end
end
class Rack::Builder
  def call(env); end
  def freeze_app; end
  def generate_map(default_app, mapping); end
  def initialize(default_app = nil, **options, &block); end
  def map(path, &block); end
  def options; end
  def run(app = nil, &block); end
  def self.app(default_app = nil, &block); end
  def self.load_file(path, **options); end
  def self.new_from_string(builder_script, path = nil, **options); end
  def self.parse_file(path, **options); end
  def to_app; end
  def use(middleware, *args, **, &block); end
  def warmup(prc = nil, &block); end
end
module Rack::BadRequest
end
class Rack::QueryParser
  def _normalize_params(params, name, v, depth); end
  def initialize(params_class, param_depth_limit); end
  def make_params; end
  def new_depth_limit(param_depth_limit); end
  def normalize_params(params, name, v, _depth = nil); end
  def param_depth_limit; end
  def params_hash_has_key?(hash, key); end
  def params_hash_type?(obj); end
  def parse_nested_query(qs, separator = nil); end
  def parse_query(qs, separator = nil, &unescaper); end
  def self.make_default(param_depth_limit); end
  def unescape(string, encoding = nil); end
end
class Rack::QueryParser::ParameterTypeError < TypeError
  include Rack::BadRequest
end
class Rack::QueryParser::InvalidParameterError < ArgumentError
  include Rack::BadRequest
end
class Rack::QueryParser::ParamsTooDeepError < RangeError
  include Rack::BadRequest
end
class Rack::QueryParser::Params < Hash
  def to_params_hash; end
end
module Rack::Mime
  def match?(value, matcher); end
  def mime_type(ext, fallback = nil); end
  def self.match?(value, matcher); end
  def self.mime_type(ext, fallback = nil); end
end
class Rack::Headers < Hash
  def [](key); end
  def []=(key, value); end
  def assoc(key); end
  def compare_by_identity; end
  def delete(key); end
  def dig(key, *a); end
  def downcase_key(key); end
  def except(*a); end
  def fetch(key, *default, &block); end
  def fetch_values(*a); end
  def has_key?(key); end
  def include?(key); end
  def invert; end
  def key?(key); end
  def member?(key); end
  def merge!(hash, &block); end
  def merge(hash, &block); end
  def reject(&block); end
  def replace(hash); end
  def select(&block); end
  def self.[](*items); end
  def slice(*a); end
  def store(key, value); end
  def to_proc; end
  def transform_keys!; end
  def transform_keys(&block); end
  def transform_values(&block); end
  def update(hash, &block); end
  def values_at(*keys); end
end
module Rack::Utils
  def best_q_match(q_value_header, available_mimes); end
  def build_nested_query(value, prefix = nil); end
  def build_query(params); end
  def byte_ranges(env, size); end
  def clean_path_info(path_info); end
  def clock_time; end
  def delete_cookie_header!(headers, key, value = nil); end
  def delete_set_cookie_header!(header, key, value = nil); end
  def delete_set_cookie_header(key, value = nil); end
  def escape(s); end
  def escape_cookie_key(key); end
  def escape_html(arg0); end
  def escape_path(s); end
  def forwarded_values(forwarded_header); end
  def get_byte_ranges(http_range, size); end
  def parse_cookies(env); end
  def parse_cookies_header(value); end
  def parse_nested_query(qs, d = nil); end
  def parse_query(qs, d = nil, &unescaper); end
  def q_values(q_value_header); end
  def rfc2822(time); end
  def secure_compare(a, b); end
  def select_best_encoding(available_encodings, accept_encoding); end
  def self.best_q_match(q_value_header, available_mimes); end
  def self.build_nested_query(value, prefix = nil); end
  def self.build_query(params); end
  def self.byte_ranges(env, size); end
  def self.clean_path_info(path_info); end
  def self.clock_time; end
  def self.default_query_parser; end
  def self.default_query_parser=(arg0); end
  def self.delete_cookie_header!(headers, key, value = nil); end
  def self.delete_set_cookie_header!(header, key, value = nil); end
  def self.delete_set_cookie_header(key, value = nil); end
  def self.escape(s); end
  def self.escape_cookie_key(key); end
  def self.escape_html(arg0); end
  def self.escape_path(s); end
  def self.forwarded_values(forwarded_header); end
  def self.get_byte_ranges(http_range, size); end
  def self.multipart_file_limit; end
  def self.multipart_file_limit=(arg0); end
  def self.multipart_part_limit; end
  def self.multipart_part_limit=(arg0); end
  def self.multipart_total_part_limit; end
  def self.multipart_total_part_limit=(arg0); end
  def self.param_depth_limit; end
  def self.param_depth_limit=(v); end
  def self.parse_cookies(env); end
  def self.parse_cookies_header(value); end
  def self.parse_nested_query(qs, d = nil); end
  def self.parse_query(qs, d = nil, &unescaper); end
  def self.q_values(q_value_header); end
  def self.rfc2822(time); end
  def self.secure_compare(a, b); end
  def self.select_best_encoding(available_encodings, accept_encoding); end
  def self.set_cookie_header!(headers, key, value); end
  def self.set_cookie_header(key, value); end
  def self.status_code(status); end
  def self.unescape(s, encoding = nil); end
  def self.unescape_path(s); end
  def self.valid_path?(path); end
  def set_cookie_header!(headers, key, value); end
  def set_cookie_header(key, value); end
  def status_code(status); end
  def unescape(s, encoding = nil); end
  def unescape_path(s); end
  def valid_path?(path); end
end
class Rack::Utils::Context
  def app; end
  def call(env); end
  def context(env, app = nil); end
  def for; end
  def initialize(app_f, app_r); end
  def recontext(app); end
end
class Rack::MediaType
  def self.params(content_type); end
  def self.strip_doublequotes(str); end
  def self.type(content_type); end
end
class Rack::Request
  def delete_param(k); end
  def initialize(env); end
  def params; end
  def self.forwarded_priority; end
  def self.forwarded_priority=(arg0); end
  def self.ip_filter; end
  def self.ip_filter=(arg0); end
  def self.x_forwarded_proto_priority; end
  def self.x_forwarded_proto_priority=(arg0); end
  def update_param(k, v); end
  include Rack::Request::Env
  include Rack::Request::Helpers
end
module Rack::Request::Env
  def add_header(key, v); end
  def delete_header(name); end
  def each_header(&block); end
  def env; end
  def fetch_header(name, &block); end
  def get_header(name); end
  def has_header?(name); end
  def initialize(env); end
  def initialize_copy(other); end
  def set_header(name, v); end
end
module Rack::Request::Helpers
  def GET; end
  def POST; end
  def accept_encoding; end
  def accept_language; end
  def allowed_scheme(header); end
  def authority; end
  def base_url; end
  def body; end
  def content_charset; end
  def content_length; end
  def content_type; end
  def cookies; end
  def default_session; end
  def delete?; end
  def delete_param(k); end
  def expand_param_pairs(pairs, query_parser = nil); end
  def form_data?; end
  def forwarded_authority; end
  def forwarded_for; end
  def forwarded_port; end
  def forwarded_priority; end
  def forwarded_scheme; end
  def fullpath; end
  def get?; end
  def get_http_forwarded(token); end
  def head?; end
  def host; end
  def host_authority; end
  def host_with_port(authority = nil); end
  def hostname; end
  def ip; end
  def link?; end
  def logger; end
  def media_type; end
  def media_type_params; end
  def options?; end
  def params; end
  def parse_http_accept_header(header); end
  def parse_multipart; end
  def parse_query(qs, d = nil); end
  def parseable_data?; end
  def patch?; end
  def path; end
  def path_info; end
  def path_info=(s); end
  def port; end
  def post?; end
  def put?; end
  def query_parser; end
  def query_string; end
  def referer; end
  def referrer; end
  def reject_trusted_ip_addresses(ip_addresses); end
  def request_method; end
  def scheme; end
  def script_name; end
  def script_name=(s); end
  def server_authority; end
  def server_name; end
  def server_port; end
  def session; end
  def session_options; end
  def split_authority(authority); end
  def split_header(value); end
  def ssl?; end
  def trace?; end
  def trusted_proxy?(ip); end
  def unlink?; end
  def update_param(k, v); end
  def url; end
  def user_agent; end
  def values_at(*keys); end
  def wrap_ipv6(host); end
  def x_forwarded_proto_priority; end
  def xhr?; end
end
class Rack::CommonLogger
  def call(env); end
  def extract_content_length(headers); end
  def initialize(app, logger = nil); end
  def log(env, status, response_headers, began_at); end
end
class Rack::ContentLength
  def call(env); end
  def initialize(app); end
  include Rack::Utils
end
class Rack::ShowExceptions
  def accepts_html?(env); end
  def call(env); end
  def dump_exception(exception); end
  def h(obj); end
  def initialize(app); end
  def prefers_plaintext?(env); end
  def pretty(env, exception); end
  def template; end
end
class Rack::ShowExceptions::Frame < Struct
  def context_line; end
  def context_line=(_); end
  def filename; end
  def filename=(_); end
  def function; end
  def function=(_); end
  def lineno; end
  def lineno=(_); end
  def post_context; end
  def post_context=(_); end
  def post_context_lineno; end
  def post_context_lineno=(_); end
  def pre_context; end
  def pre_context=(_); end
  def pre_context_lineno; end
  def pre_context_lineno=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Rack::Lint
  def call(env = nil); end
  def initialize(app); end
end
class Rack::Lint::LintError < RuntimeError
end
class Rack::Lint::Wrapper
  def call(stream); end
  def check_content_length_header(status, headers); end
  def check_content_type_header(status, headers); end
  def check_early_hints(env); end
  def check_environment(env); end
  def check_error_stream(error); end
  def check_header_value(key, value); end
  def check_headers(headers); end
  def check_hijack(env); end
  def check_hijack_response(headers, env); end
  def check_input_stream(input); end
  def check_rack_protocol_header(status, headers); end
  def check_status(status); end
  def close; end
  def each; end
  def initialize(app, env); end
  def respond_to?(name, *); end
  def response; end
  def to_ary; end
  def to_path; end
  def verify_content_length(size); end
  def verify_to_path; end
end
class Rack::Lint::Wrapper::InputWrapper
  def close(*args); end
  def each(*args); end
  def gets(*args); end
  def initialize(input); end
  def read(*args); end
end
class Rack::Lint::Wrapper::ErrorWrapper
  def close(*args); end
  def flush; end
  def initialize(error); end
  def puts(str); end
  def write(str); end
end
class Rack::Lint::Wrapper::StreamWrapper
  def <<(*args, **, &block); end
  def close(*args, **, &block); end
  def close_read(*args, **, &block); end
  def close_write(*args, **, &block); end
  def closed?(*args, **, &block); end
  def flush(*args, **, &block); end
  def initialize(stream); end
  def read(*args, **, &block); end
  def write(*args, **, &block); end
  extend Forwardable
end
class Rack::TempfileReaper
  def call(env); end
  def initialize(app); end
end
